# We're using "BundleUtilities.cmake" which was added in CMake 2.6.2.
# But we've copied it to the GPlates modules directory so that
# CMake 2.6.0 and CMake 2.6.1 can use it.
# However it makes use of cmake scripting features found only in 2.6 and above.
# NOTE: we now only support the 'DragNDrop' CPack generator which requires
# CMake 2.6.3 so that's our minimum required version - the 'PackageMaker' generator
# seems to modify user/group ownership when installed on a client system - besides
# the 'DragNDrop' generator is much easier for clients to use and it's nicer.
cmake_minimum_required(VERSION 2.6.3 FATAL_ERROR)

# Get the cmake module path used by our parent cmake scripts.
SET(CMAKE_MODULE_PATH "@CMAKE_MODULE_PATH@")

#   CPACK_PACKAGE_FILE_NAME - The name of the package file to generate,
#   not including the extension. For example, cmake-2.6.1-Linux-i686.
#
# CPACK_PACKAGE_FILE_NAME is set to the default for public releases in Package.cmake.
# Here we change it to add the SVN revision number for non-public releases - see Package.cmake for
# why this has to be done here.
SET(GPLATES_PACKAGE_VERSION_WITH_SVN_REVISION "@GPlates_VERSION@")
# Add the Subversion version number to the package filename if this is a non-public release.
# A non-public release has an empty 'GPLATES_SOURCE_CODE_CONTROL_VERSION_STRING' variable in 'ConfigDefault.cmake'.
IF (NOT "@GPLATES_SOURCE_CODE_CONTROL_VERSION_STRING@")
	# Get the location, inside the staging area location, to copy the application bundle to.
	EXECUTE_PROCESS(
			COMMAND svnversion @GPlates_SOURCE_DIR@
			RESULT_VARIABLE SVN_VERSION_RESULT
			OUTPUT_VARIABLE SVN_VERSION_OUTPUT
			OUTPUT_STRIP_TRAILING_WHITESPACE
		   )

	IF (SVN_VERSION_RESULT)
		MESSAGE(STATUS "Unable to determine svn version number for non-public release - ignoring.")
	ELSE (SVN_VERSION_RESULT)
		# The 'svnversion' command can output a range of revisions with a colon separator - but this causes problems
		# with filenames so we'll remove the start revision and the colon after it (leaving the end revision).
		STRING(REGEX REPLACE "^.*:" "" SVN_VERSION ${SVN_VERSION_OUTPUT})
		# Set the updated package version.
		SET(GPLATES_PACKAGE_VERSION_WITH_SVN_REVISION "@GPlates_VERSION@_r${SVN_VERSION}")
	ENDIF (SVN_VERSION_RESULT)
ENDIF (NOT "@GPLATES_SOURCE_CODE_CONTROL_VERSION_STRING@")

# Finally set the actual package filename.
# The CMAKE_SYSTEM_PROCESSOR has been set as "uname -p" by cmake. The value is incorrect on Lion and Mountain Lion.
# Change it to "uname -m". This distinguishes between 32-bit and 64-bit. 
FIND_PROGRAM(UNAME uname /bin /usr/bin /usr/local/bin)
IF (UNAME)
  EXEC_PROGRAM(uname ARGS -m OUTPUT_VARIABLE CMAKE_MACHINE_HARDWARE_NAME)
  SET(CPACK_PACKAGE_FILE_NAME "@GPLATES_PACKAGE_NAME@-${GPLATES_PACKAGE_VERSION_WITH_SVN_REVISION}-@CMAKE_SYSTEM_NAME@-${CMAKE_MACHINE_HARDWARE_NAME}")
ELSE (UNAME)
  SET(CPACK_PACKAGE_FILE_NAME "@GPLATES_PACKAGE_NAME@-${GPLATES_PACKAGE_VERSION_WITH_SVN_REVISION}-@CMAKE_SYSTEM_NAME@-@CMAKE_SYSTEM_PROCESSOR@")
ENDIF (UNAME)
MESSAGE(STATUS "Package name: ${CPACK_PACKAGE_FILE_NAME}")

# Write the "Package.cpack" file.
# NOTE: "CPACK_PACKAGE_FILE_NAME" comes from this script above and not from when CONFIGURE_FILE was
# run over this script (ie, using ${CPACK_PACKAGE_FILE_NAME} instead of @CPACK_PACKAGE_FILE_NAME@).
file(WRITE "@PACKAGE_CPACK_CONFIG@"
	"SET(CPACK_PACKAGE_NAME \"@CPACK_PACKAGE_NAME@\")\n"
	"SET(CPACK_PACKAGE_VENDOR \"@CPACK_PACKAGE_VENDOR@\")\n"
	"SET(CPACK_PACKAGE_VERSION_MAJOR \"@CPACK_PACKAGE_VERSION_MAJOR@\")\n"
	"SET(CPACK_PACKAGE_VERSION_MINOR \"@CPACK_PACKAGE_VERSION_MINOR@\")\n"
	"SET(CPACK_PACKAGE_VERSION_PATCH \"@CPACK_PACKAGE_VERSION_PATCH@\")\n"
	"SET(CPACK_PACKAGE_DESCRIPTION_FILE \"@CPACK_PACKAGE_DESCRIPTION_FILE@\")\n"
	"SET(CPACK_PACKAGE_DESCRIPTION_SUMMARY \"@CPACK_PACKAGE_DESCRIPTION_SUMMARY@\")\n"
	"SET(CPACK_PACKAGE_FILE_NAME \"${CPACK_PACKAGE_FILE_NAME}\")\n"
	"SET(CPACK_RESOURCE_FILE_LICENSE \"@CPACK_RESOURCE_FILE_LICENSE@\")\n"
	"SET(CPACK_RESOURCE_FILE_README \"@CPACK_RESOURCE_FILE_README@\")\n"
	"SET(CPACK_RESOURCE_FILE_WELCOME \"@CPACK_RESOURCE_FILE_WELCOME@\")\n"
	"SET(CPACK_MONOLITHIC_INSTALL \"@CPACK_MONOLITHIC_INSTALL@\")\n"
	"SET(CPACK_OUTPUT_CONFIG_FILE \"@CPACK_OUTPUT_CONFIG_FILE@\")\n"
	"SET(CPACK_PACKAGE_EXECUTABLES \"@CPACK_PACKAGE_EXECUTABLES@\")\n"
	"SET(CPACK_STRIP_FILES \"@CPACK_STRIP_FILES@\")\n"
	"SET(CPACK_SOURCE_PACKAGE_FILE_NAME \"@CPACK_SOURCE_PACKAGE_FILE_NAME@\")\n"
	"SET(CPACK_SOURCE_STRIP_FILES \"@CPACK_SOURCE_STRIP_FILES@\")\n"
	"SET(CPACK_SOURCE_OUTPUT_CONFIG_FILE \"@CPACK_SOURCE_OUTPUT_CONFIG_FILE@\")\n"
	"SET(CPACK_SOURCE_IGNORE_FILES \"@CPACK_SOURCE_IGNORE_FILES@\")\n"
	"SET(CPACK_CMAKE_GENERATOR \"@CPACK_CMAKE_GENERATOR@\")\n"
	"SET(CPACK_INSTALL_CMAKE_PROJECTS \"@CPACK_INSTALL_CMAKE_PROJECTS@\")\n"
	"SET(CPACK_SYSTEM_NAME \"@CPACK_SYSTEM_NAME@\")\n"
	"SET(CPACK_PACKAGE_VERSION \"@CPACK_PACKAGE_VERSION@\")\n"
	"SET(CPACK_TOPLEVEL_TAG \"@CPACK_TOPLEVEL_TAG@\")\n"
	"SET(CPACK_INSTALL_COMMANDS \"@CPACK_INSTALL_COMMANDS@\")\n"
	"SET(CPACK_INSTALL_DIRECTORIES \"@CPACK_INSTALL_DIRECTORIES@\")\n"
	"SET(CPACK_PACKAGE_INSTALL_REGISTRY_KEY \"@CPACK_PACKAGE_INSTALL_REGISTRY_KEY@\")\n"
	"SET(CPACK_NSIS_MUI_ICON \"@CPACK_NSIS_MUI_ICON@\")\n"
	"SET(CPACK_NSIS_MUI_UNIICON \"@CPACK_NSIS_MUI_UNIICON@\")\n"
	"SET(CPACK_PACKAGE_ICON \"@CPACK_PACKAGE_ICON@\")\n"
	"SET(CPACK_NSIS_EXTRA_INSTALL_COMMANDS \"@CPACK_NSIS_EXTRA_INSTALL_COMMANDS@\")\n"
	"SET(CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS \"@CPACK_NSIS_EXTRA_UNINSTALL_COMMANDS@\")\n"
	"SET(CPACK_NSIS_COMPRESSOR \"@CPACK_NSIS_COMPRESSOR@\")\n"
	"SET(CPACK_NSIS_MODIFY_PATH \"@CPACK_NSIS_MODIFY_PATH@\")\n"
	"SET(CPACK_NSIS_DISPLAY_NAME \"@CPACK_NSIS_DISPLAY_NAME@\")\n"
	"SET(CPACK_NSIS_INSTALLED_ICON_NAME \"@CPACK_NSIS_INSTALLED_ICON_NAME@\")\n"
	"SET(CPACK_NSIS_HELP_LINK \"@CPACK_NSIS_HELP_LINK@\")\n"
	"SET(CPACK_NSIS_URL_INFO_ABOUT \"@CPACK_NSIS_URL_INFO_ABOUT@\")\n"
	"SET(CPACK_NSIS_CONTACT \"@CPACK_NSIS_CONTACT@\")\n"
	"SET(CPACK_NSIS_CREATE_ICONS_EXTRA \"@CPACK_NSIS_CREATE_ICONS_EXTRA@\")\n"
	"SET(CPACK_NSIS_DELETE_ICONS_EXTRA \"@CPACK_NSIS_DELETE_ICONS_EXTRA@\")\n"
	"SET(CPACK_GENERATOR \"@CPACK_GENERATOR@\")\n"
	"SET(CPACK_BINARY_NSIS \"@CPACK_BINARY_NSIS@\")\n"
	"SET(CPACK_INSTALLED_DIRECTORIES \"@CPACK_INSTALLED_DIRECTORIES@\")\n"
	"SET(CPACK_PACKAGE_INSTALL_DIRECTORY \"@CPACK_PACKAGE_INSTALL_DIRECTORY@\")\n"
	"SET(CPACK_PACKAGING_INSTALL_PREFIX \"@CPACK_PACKAGING_INSTALL_PREFIX@\")\n"
	"SET(CPACK_SOURCE_GENERATOR \"@CPACK_SOURCE_GENERATOR@\")\n"
	"SET(CPACK_OSX_PACKAGE_VERSION \"@CPACK_OSX_PACKAGE_VERSION@\")\n"
	"SET(CPACK_PACKAGE_RELOCATABLE \"@CPACK_PACKAGE_RELOCATABLE@\")\n")

#
# NOTE: the following function "gp_item_default_embedded_path_override"
# is copied from the "GetPrerequisites.cmake" module and altered
# to change the location in the app bundle of any Qt plugins we use.
# The idea is if we provide this function before including
# the "GetPrerequisites.cmake" module it will call our function.
#

# gp_item_default_embedded_path item default_embedded_path_var
#
# Return the path that others should refer to the item by when the item
# is embedded inside a bundle.
#
# Override on a per-project basis by providing a project-specific
# gp_item_default_embedded_path_override function.
#
function(gp_item_default_embedded_path_override item default_embedded_path_var)
  #
  # The assumption here is that all executables in the bundle will be
  # in same-level-directories inside the bundle. The parent directory
  # of an executable inside the bundle should be MacOS or a sibling of
  # MacOS and all embedded paths returned from here will begin with
  # "@executable_path/../" and will work from all executables in all
  # such same-level-directories inside the bundle.
  #

  # By default, embed things right next to the main bundle executable:
  #
  set(path "@executable_path/../../Contents/MacOS")

  set(overridden 0)

  # See if "item" matches any of our Qt plugins and embed them
  # in the embedded 'plugins' directory (sibling of MacOS):
  #
  foreach(qtplugin @GPLATES_QT_PLUGINS_MACOSX@)
    # 'qtplugin' looks like 'imageformats/libqjpeg.dylib' for example.
    if(item MATCHES "${qtplugin}$")
      get_filename_component(qtplugin_path "${qtplugin}" PATH)
      # For example, replace '/Developer/Appliations/Qt/plugins/imageformats/libqjpeg.dylib' with
      # '@executable_path/../plugins/imageformats'.
      set(path "@executable_path/../plugins/${qtplugin_path}")
      set(overridden 1)
    endif(item MATCHES "${qtplugin}$")
  endforeach(qtplugin)

  # Embed .dylibs right next to the main bundle executable:
  #
  if(NOT overridden)
    if(item MATCHES "\\.dylib$")
      set(path "@executable_path/../MacOS")
      set(overridden 1)
    endif(item MATCHES "\\.dylib$")
  endif(NOT overridden)

  # Embed frameworks in the embedded "Frameworks" directory (sibling of MacOS):
  #
  if(NOT overridden)
    if(item MATCHES "[^/]+\\.framework/")
      set(path "@executable_path/../Frameworks")
      set(overridden 1)
    endif(item MATCHES "[^/]+\\.framework/")
  endif(NOT overridden)

  set(${default_embedded_path_var} "${path}" PARENT_SCOPE)
endfunction(gp_item_default_embedded_path_override)


# The path location to the bundle staging area.
SET(OSX_GET_BUNDLE_STAGING_AREA_LOCATION "@STAGING_AREA_FOR_CPACK@/@GPLATES_PACKAGE_NAME@-${GPLATES_PACKAGE_VERSION_WITH_SVN_REVISION}")

# Make sure the staging area directory exists.
EXECUTE_PROCESS(COMMAND "@CMAKE_COMMAND@" -E make_directory "@STAGING_AREA_FOR_CPACK@")
EXECUTE_PROCESS(COMMAND "@CMAKE_COMMAND@" -E make_directory "${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}")

# Copy the application bundle to the staging area location.
MESSAGE("Bundle location is ${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}")
EXECUTE_PROCESS(
		COMMAND "@OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_SHELL_SCRIPT@" "${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}"
		RESULT_VARIABLE OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_RESULT
	   )

IF (OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_RESULT)
		MESSAGE(FATAL_ERROR "Error moving built Mac OSX bundle to staging area for CPack.")
ENDIF (OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_RESULT)

# Run the BundleUtilities cmake code.
# This will copy any non-system libraries into the bundle making it standalone.
# fixup_bundle() will generate a FATAL_ERROR if bundle fails validation.
include(BundleUtilities)
fixup_bundle("${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app"
	"@GPLATES_QT_PLUGINS_ABSOLUTE@"
	"@GPLATES_QT_PLUGIN_PATHS_ABSOLUTE@;/usr/local/lib;/usr/lib;/opt/local/lib")

# Copy the "qt.conf" file to the 'Resources' directory of the app bundle.
# This is where Qt looks for it.
# It in turn tells Qt to look for plugins in the "Contents/plugins" directory.
EXECUTE_PROCESS(
		COMMAND "@CMAKE_COMMAND@" -E copy
			"@GPLATES_SOURCE_DISTRIBUTION_DIR@/qt.conf" 
			"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/qt.conf" 
		RESULT_VARIABLE COPY_QT_CONF_RESULT
		)

IF (COPY_QT_CONF_RESULT)
		MESSAGE(FATAL_ERROR "Error copying 'qt.conf' to Mac OSX bundle 'Resources' directory.")
ENDIF (COPY_QT_CONF_RESULT)

# Copy the "scripts/" directory from the root of the source tree to the 'Resources' directory of the app bundle.
# This is where Qt looks for it.
# It in turn tells Qt to look for plugins in the "Contents/plugins" directory.
# First create the scripts target directory in the bundle.
EXECUTE_PROCESS(
		COMMAND "@CMAKE_COMMAND@" -E make_directory
			"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/scripts" 
		RESULT_VARIABLE MAKE_SCRIPTS_DIR_RESULT
		)
IF (MAKE_SCRIPTS_DIR_RESULT)
	MESSAGE(STATUS "Error creating 'scripts' directory in Mac OSX bundle - ignoring python scripts.")
ELSE (MAKE_SCRIPTS_DIR_RESULT)
	# Next copy the scripts directory into the bundle.
	EXECUTE_PROCESS(
			COMMAND "@CMAKE_COMMAND@" -E copy_directory
				"@GPlates_SOURCE_DIR@/scripts" 
				"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/scripts" 
			RESULT_VARIABLE COPY_SCRIPTS_DIR_RESULT
			)
	IF (COPY_SCRIPTS_DIR_RESULT)
		MESSAGE(STATUS "Error copying 'scripts' directory in Mac OSX bundle - ignoring python scripts.")
	ELSE (COPY_SCRIPTS_DIR_RESULT)
		# Finally remove the 'scripts/.svn' subdirectory copied over from the source tree.
		EXECUTE_PROCESS(
				COMMAND "@CMAKE_COMMAND@" -E remove_directory
					"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/scripts/.svn" 
				RESULT_VARIABLE COPY_SCRIPTS_DIR_RESULT
				)
	ENDIF (COPY_SCRIPTS_DIR_RESULT)
ENDIF (MAKE_SCRIPTS_DIR_RESULT)

#MESSAGE(STATUS "copying python framework libraries into bundle -- @PYTHON_FRAMEWORK_ROOT@.")
#	EXECUTE_PROCESS(
#                        COMMAND "@CMAKE_COMMAND@" -E copy_directory 
#                                "@PYTHON_FRAMEWORK_ROOT@"
#                                "${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app/Contents/Frameworks/Python.Framework/Versions/@PYTHON_FRAMEWORK_VERSION@"
#                        RESULT_VARIABLE COPY_PYTHON_FRAMEWORK_RESULT
#                        )

#fixup_bundle(
#	"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION}/@GPLATES_MAIN_TARGET@.app/Contents/Frameworks/Python.Framework/Versions/@PYTHON_FRAMEWORK_VERSION@"
#	"@GPLATES_QT_PLUGINS_ABSOLUTE@"
#        "@GPLATES_QT_PLUGIN_PATHS_ABSOLUTE@;/usr/local/lib;/usr/lib;/opt/local/lib")

# Invoke CPack to package up the standalone bundle into an installer.
EXECUTE_PROCESS(
		COMMAND "@OSX_CREATE_INSTALLER_FROM_STANDALONE_BUNDLE_SHELL_SCRIPT@"
		RESULT_VARIABLE OSX_MAKE_INSTALLER_FROM_STANDALONE_BUNDLE_RESULT
		)

IF (OSX_MAKE_INSTALLER_FROM_STANDALONE_BUNDLE_RESULT)
		MESSAGE(FATAL_ERROR "Error moving built Mac OSX bundle to staging area for CPack.")
ENDIF (OSX_MAKE_INSTALLER_FROM_STANDALONE_BUNDLE_RESULT)
