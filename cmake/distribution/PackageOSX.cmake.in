# We're using "BundleUtilities.cmake" which was added in CMake 2.6.2.
# But we've copied it to the GPlates modules directory so that
# CMake 2.6.0 and CMake 2.6.1 can use it.
# However it makes use of cmake scripting features found only in 2.6 and above.
# NOTE: we now only support the 'DragNDrop' CPack generator which requires
# CMake 2.6.3 so that's our minimum required version - the 'PackageMaker' generator
# seems to modify user/group ownership when installed on a client system - besides
# the 'DragNDrop' generator is much easier for clients to use and it's nicer.
cmake_minimum_required(VERSION 2.6.3 FATAL_ERROR)

# Get the cmake module path used by our parent cmake scripts.
SET(CMAKE_MODULE_PATH "@CMAKE_MODULE_PATH@")

#
# NOTE: the following function "gp_item_default_embedded_path_override"
# is copied from the "GetPrerequisites.cmake" module and altered
# to change the location in the app bundle of any Qt plugins we use.
# The idea is if we provide this function before including
# the "GetPrerequisites.cmake" module it will call our function.
#

# gp_item_default_embedded_path item default_embedded_path_var
#
# Return the path that others should refer to the item by when the item
# is embedded inside a bundle.
#
# Override on a per-project basis by providing a project-specific
# gp_item_default_embedded_path_override function.
#
function(gp_item_default_embedded_path_override item default_embedded_path_var)
  #
  # The assumption here is that all executables in the bundle will be
  # in same-level-directories inside the bundle. The parent directory
  # of an executable inside the bundle should be MacOS or a sibling of
  # MacOS and all embedded paths returned from here will begin with
  # "@executable_path/../" and will work from all executables in all
  # such same-level-directories inside the bundle.
  #

  # By default, embed things right next to the main bundle executable:
  #
  set(path "@executable_path/../../Contents/MacOS")

  set(overridden 0)

  # See if "item" matches any of our Qt plugins and embed them
  # in the embedded 'plugins' directory (sibling of MacOS):
  #
  foreach(qtplugin @GPLATES_QT_PLUGINS_MACOSX@)
    # 'qtplugin' looks like 'imageformats/libqjpeg.dylib' for example.
    if(item MATCHES "${qtplugin}$")
      get_filename_component(qtplugin_path "${qtplugin}" PATH)
      # For example, replace '/Developer/Appliations/Qt/plugins/imageformats/libqjpeg.dylib' with
      # '@executable_path/../plugins/imageformats'.
      set(path "@executable_path/../plugins/${qtplugin_path}")
      set(overridden 1)
    endif(item MATCHES "${qtplugin}$")
  endforeach(qtplugin)

  # Embed .dylibs right next to the main bundle executable:
  #
  if(NOT overridden)
    if(item MATCHES "\\.dylib$")
      set(path "@executable_path/../MacOS")
      set(overridden 1)
    endif(item MATCHES "\\.dylib$")
  endif(NOT overridden)

  # Embed frameworks in the embedded "Frameworks" directory (sibling of MacOS):
  #
  if(NOT overridden)
    if(item MATCHES "[^/]+\\.framework/")
      set(path "@executable_path/../Frameworks")
      set(overridden 1)
    endif(item MATCHES "[^/]+\\.framework/")
  endif(NOT overridden)

  set(${default_embedded_path_var} "${path}" PARENT_SCOPE)
endfunction(gp_item_default_embedded_path_override)

# Get the location, inside the staging area location, to copy the application bundle to.
EXECUTE_PROCESS(
		COMMAND "@OSX_GET_BUNDLE_STAGING_AREA_LOCATION_SHELL_SCRIPT@" "@CMAKE_SOURCE_DIR@" "@GPLATES_SOURCE_CODE_CONTROL_VERSION_STRING@"
		RESULT_VARIABLE OSX_GET_BUNDLE_STAGING_AREA_LOCATION_RESULT
		OUTPUT_VARIABLE OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT
		OUTPUT_STRIP_TRAILING_WHITESPACE
	   )

IF (OSX_GET_BUNDLE_STAGING_AREA_LOCATION_RESULT)
		MESSAGE(FATAL_ERROR "Error determining location in CPack staging area to copy built Mac OSX bundle to.")
ENDIF (OSX_GET_BUNDLE_STAGING_AREA_LOCATION_RESULT)


# Copy the application bundle to the staging area location.
MESSAGE("Bundle location is ${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}")
EXECUTE_PROCESS(
		COMMAND "@OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_SHELL_SCRIPT@" "${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}"
		RESULT_VARIABLE OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_RESULT
	   )

IF (OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_RESULT)
		MESSAGE(FATAL_ERROR "Error moving built Mac OSX bundle to staging area for CPack.")
ENDIF (OSX_COPY_BUNDLE_TO_CPACK_STAGING_AREA_RESULT)

# Run the BundleUtilities cmake code.
# This will copy any non-system libraries into the bundle making it standalone.
# fixup_bundle() will generate a FATAL_ERROR if bundle fails validation.
include(BundleUtilities)
fixup_bundle("${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}/@GPLATES_MAIN_TARGET@.app"
	"@GPLATES_QT_PLUGINS_ABSOLUTE@"
	"@GPLATES_QT_PLUGIN_PATHS_ABSOLUTE@;/usr/local/lib;/usr/lib;/opt/local/lib")

# Copy the "qt.conf" file to the 'Resources' directory of the app bundle.
# This is where Qt looks for it.
# It in turn tells Qt to look for plugins in the "Contents/plugins" directory.
EXECUTE_PROCESS(
		COMMAND "@CMAKE_COMMAND@" -E copy
			"@GPLATES_SOURCE_DISTRIBUTION_DIR@/qt.conf" 
			"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/qt.conf" 
		RESULT_VARIABLE COPY_QT_CONF_RESULT
		)

IF (COPY_QT_CONF_RESULT)
		MESSAGE(FATAL_ERROR "Error copying 'qt.conf' to Mac OSX bundle 'Resources' directory.")
ENDIF (COPY_QT_CONF_RESULT)

# Copy the "scripts/" directory from the root of the source tree to the 'Resources' directory of the app bundle.
# This is where Qt looks for it.
# It in turn tells Qt to look for plugins in the "Contents/plugins" directory.
# First create the scripts target directory in the bundle.
EXECUTE_PROCESS(
		COMMAND "@CMAKE_COMMAND@" -E make_directory
			"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/scripts" 
		RESULT_VARIABLE MAKE_SCRIPTS_DIR_RESULT
		)
IF (MAKE_SCRIPTS_DIR_RESULT)
	MESSAGE(STATUS "Error creating 'scripts' directory in Mac OSX bundle - ignoring python scripts.")
ELSE (MAKE_SCRIPTS_DIR_RESULT)
	# Next copy the scripts directory into the bundle.
	EXECUTE_PROCESS(
			COMMAND "@CMAKE_COMMAND@" -E copy_directory
				"@CMAKE_SOURCE_DIR@/scripts" 
				"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/scripts" 
			RESULT_VARIABLE COPY_SCRIPTS_DIR_RESULT
			)
	IF (COPY_SCRIPTS_DIR_RESULT)
		MESSAGE(STATUS "Error copying 'scripts' directory in Mac OSX bundle - ignoring python scripts.")
	ELSE (COPY_SCRIPTS_DIR_RESULT)
		# Finally remove the 'scripts/.svn' subdirectory copied over from the source tree.
		EXECUTE_PROCESS(
				COMMAND "@CMAKE_COMMAND@" -E remove_directory
					"${OSX_GET_BUNDLE_STAGING_AREA_LOCATION_OUTPUT}/@GPLATES_MAIN_TARGET@.app/Contents/Resources/scripts/.svn" 
				RESULT_VARIABLE COPY_SCRIPTS_DIR_RESULT
				)
	ENDIF (COPY_SCRIPTS_DIR_RESULT)
ENDIF (MAKE_SCRIPTS_DIR_RESULT)

# Invoke CPack to package up the standalone bundle into an installer.
EXECUTE_PROCESS(
		COMMAND "@OSX_CREATE_INSTALLER_FROM_STANDALONE_BUNDLE_SHELL_SCRIPT@"
		RESULT_VARIABLE OSX_MAKE_INSTALLER_FROM_STANDALONE_BUNDLE_RESULT
		)

IF (OSX_MAKE_INSTALLER_FROM_STANDALONE_BUNDLE_RESULT)
		MESSAGE(FATAL_ERROR "Error moving built Mac OSX bundle to staging area for CPack.")
ENDIF (OSX_MAKE_INSTALLER_FROM_STANDALONE_BUNDLE_RESULT)
