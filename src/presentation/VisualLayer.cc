/* $Id$ */
 
/**
 * \file 
 * $Revision$
 * $Date$
 * 
 * Copyright (C) 2010 The University of Sydney, Australia
 *
 * This file is part of GPlates.
 *
 * GPlates is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 2, as published by
 * the Free Software Foundation.
 *
 * GPlates is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <boost/foreach.hpp>

#include "VisualLayer.h"

#include "ReconstructionGeometryRenderer.h"

#include "app-logic/ReconstructionGeometryCollection.h"


GPlatesPresentation::VisualLayer::VisualLayer(
		const GPlatesAppLogic::Layer &layer,
		GPlatesViewOperations::RenderedGeometryCollection &rendered_geometry_collection) :
	d_layer(layer),
	// Create a child rendered geometry layer in the main RECONSTRUCTION layer.
	d_rendered_geometry_layer(
			rendered_geometry_collection.create_child_rendered_layer_and_transfer_ownership(
					GPlatesViewOperations::RenderedGeometryCollection::RECONSTRUCTION_LAYER))
{
}


void
GPlatesPresentation::VisualLayer::create_rendered_geometries()
{
	// Delay any notification of changes to the rendered geometry collection
	// until end of current scope block. This is so we can do multiple changes
	// without any canvas' redrawing themselves after each change.
	// This should ideally be located at the highest level to capture one
	// user GUI interaction - the user performs an action and we update canvas once.
	// But since these guards can be nested it's probably a good idea to have it here too.
	GPlatesViewOperations::RenderedGeometryCollection::UpdateGuard update_guard;

	// Activate the layer.
	d_rendered_geometry_layer->set_active();	
	// Clear all RenderedGeometry's before adding new ones.
	d_rendered_geometry_layer->clear_rendered_geometries();	

	// Get the most recent output data generated by this layer and see if it contains
	// reconstruction geometries.
	boost::optional<GPlatesAppLogic::ReconstructionGeometryCollection::non_null_ptr_to_const_type>
			reconstruction_geometry_collection = d_layer.get_output_data<
					GPlatesAppLogic::ReconstructionGeometryCollection::non_null_ptr_to_const_type>();
	if (!reconstruction_geometry_collection)
	{
		// Return with an empty rendered geometry layer.
		return;
	}

	// This creates the RenderedGeometry's from the ReconstructionGeometry's.
	GPlatesPresentation::ReconstructionGeometryRenderer reconstruction_geometry_renderer(
			*d_rendered_geometry_layer);

	// Iterate over the reconstruction geometries in the collection.
	GPlatesAppLogic::ReconstructionGeometryCollection::const_iterator reconstruction_geometry_iter =
			reconstruction_geometry_collection.get()->begin();
	GPlatesAppLogic::ReconstructionGeometryCollection::const_iterator reconstruction_geometry_end =
			reconstruction_geometry_collection.get()->end();
	for ( ; reconstruction_geometry_iter != reconstruction_geometry_end; ++reconstruction_geometry_iter)
	{
		GPlatesAppLogic::ReconstructionGeometry::non_null_ptr_to_const_type reconstruction_geometry =
				*reconstruction_geometry_iter;

		reconstruction_geometry->accept_visitor(reconstruction_geometry_renderer);
	}
}
