/**
 * Copyright (C) 2022 The University of Sydney, Australia
 *
 * This file is part of GPlates.
 *
 * GPlates is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 2, as published by
 * the Free Software Foundation.
 *
 * GPlates is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

//
// Scales arrows according to viewport zoom and culls arrows outside the view frustum.
//
// And performs map projection (when map view is active).
//

layout (push_constant) uniform PushConstants
{
    vec4 frustum_planes[6];
    float arrow_size_scale_factor;
    float max_ratio_arrowhead_length_to_arrow_length;
    float arrowhead_width_to_length_ratio;
    bool use_map_projection;  // true/false if rendering in map/globe view
    float map_projection_central_meridian;  // only used if 'use_map_projection' is true
    uint num_input_arrow_instances;
};

struct InputArrowInstance
{
    vec3 arrow_start;  // (x, y, z) position on globe of base of arrow
    float arrow_body_width;  // fills alignment padding
    vec3 arrow_vector;  // direction and magnitude of arrow in world space
    float arrowhead_length;  // fills alignment padding
    vec4 colour;  // arrow colour
};

struct OutputArrowInstance
{
    vec3 world_space_start_position;  // (x, y, z) position in world space of base of arrow
    float arrow_body_width;  // fills alignment padding

    vec3 world_space_x_axis;  // frame of reference of arrow instance
    float arrowhead_width;  // fills alignment padding

    vec3 world_space_y_axis;  // frame of reference of arrow instance
    float arrow_body_length;  // fills alignment padding

    vec3 world_space_z_axis;  // direction arrow is pointing (unit vector)
    float arrowhead_length;  // fills alignment padding

    // Arrow colour.
    vec4 colour;
};

layout (set = 0, binding = 0) readonly buffer InputArrowInstances
{
    InputArrowInstance instances[];
} input_arrow_instances;

layout (set = 0, binding = 1) writeonly buffer OutputArrowInstances
{
    OutputArrowInstance instances[];
} output_arrow_instances;

// Same layout as VkDrawIndexedIndirectCommand
struct IndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout (set = 0, binding = 2) buffer IndirectDraw
{
    IndexedIndirectCommand command;
} indirect_draw;

layout (set = 1, binding = 0) uniform sampler2D map_projection_sampler;

layout (local_size_x_id = 1) in;  // Set 'local_size_x' using the Vulkan API

const float PI = radians(180);
const float HALF_PI = radians(180) / 2.0;

/*
 * Project a position on the unit sphere onto the 2D map projection.
 */
vec2
map_project_position(
        vec3 position)
{
    // Get latitude from position on sphere.
    float latitude = asin(position.z);  // in range [-PI/2, PI/2]

    // Get longitude from position on sphere.
    float longitude = atan(position.y, position.x);  // in range [-PI, PI]
    // Centre about the central meridian (so it has a longitude of zero).
    longitude -= map_projection_central_meridian;    // in range [-PI - central_meridian, PI - central_meridian]

    // Ensure longitude is in the range [-PI, PI] by:
    // wrapping [-PI - |central_meridian|, -PI] to [PI - |central_meridian|, PI] when central_meridian > 0, and
    // wrapping [PI, PI + |central_meridian|] to [-PI, -PI + |central_meridian|] when central_meridian < 0.
    if (longitude < -PI)  // central_meridian > 0
    {
        longitude += 2 * PI;
    }
    else if (longitude > PI)  // central_meridian < 0
    {
        longitude -= 2 * PI;
    }

    // Map projection texture coordinate uses longitude and latitude.
    vec2 map_projection_tex_coord = vec2(
            // Convert longitude from [-PI, PI] to [0, 1]...
            (longitude + PI) / (2 * PI),
            // Convert latitude from [-PI/2, PI/2] to [0, 1]...
            (latitude + HALF_PI) / PI);

    // Adjust for half texel since boundary of [0, 1] range maps to the texel centres of the boundary texels.
    // Everything in between is linearly interpolated.
    vec2 map_projection_resolution = textureSize(map_projection_sampler, 0);
    map_projection_tex_coord = ((map_projection_resolution - 1) * map_projection_tex_coord + 0.5) / map_projection_resolution;

    // Sample map projection texture to get 2D position on map projection plane.
    return texture(map_projection_sampler, map_projection_tex_coord).xy;
}

/*
 * Project a 3D vector onto the 2D map projection.
 *
 * The final map projected vector is actually a 3D vector where the 2D (x,y) component is in the 2D map plane and
 * the z component is along the z-axis of 3D map projection space.
 */
vec3
map_project_vector(
        vec3 position,  // position of base of vector on the unit sphere
        vec3 vector)
{
    //
    // Find the local East, North and down directions at 'position' on the unit sphere.
    //

    vec3 local_east = cross(vec3(0,0,1)/*global North*/, position);
    float len_local_east = length(local_east);
    if (len_local_east == 0)
    {
        // Position is at the North pole, so all tangential directions point towards North.
        // So just choose an arbitrary tangential direction (eg, global East).
        local_east = vec3(0,1,0);  // global East
    }
    else
    {
        local_east /= len_local_east;  // normalize
    }

    vec3 local_north = cross(position, local_east);  // no need to normalize (cross of two perpendicular unit vectors)
    vec3 local_down = -position;

    // Convert vector into local (East, North, down) frame of reference.
    return vec3(
            dot(vector, local_east),
            dot(vector, local_north),
            dot(vector, local_down));
}

/*
 * Returns true if sphere intersects frustum.
 *
 * This test is conservative, so sphere can be outside frustum and still return true.
 */
bool
sphere_intersects_frustum(
        vec3 sphere_centre,
        float sphere_radius)
{
    for (int i = 0; i < 6; i++)
    {
        if (dot(vec4(sphere_centre, 1.0), frustum_planes[i]) + sphere_radius < 0.0)
        {
            // Sphere is outside a single frustum plane.
            return false;
        }
    }

    return true;
}

/*
 * Generate an arbitray perpendicular unit vector to the specified vector.
 */
vec3
generate_perpendicular(
        vec3 vector)
{
    // Use the basis vector that's most perpendicular (lowest dot product) to the input vector.
    if (vector.x < vector.y)
    {
        if (vector.x < vector.z)
        {
            return normalize(cross(vector, vec3(1,0,0)));
        }
        else  // vector.z <= vector.x
        {
            return normalize(cross(vector, vec3(0,0,1)));
        }
    }
    else  // vector.y <= vector.x
    {
        if (vector.y < vector.z)
        {
            return normalize(cross(vector, vec3(0,1,0)));
        }
        else  // vector.z <= vector.y
        {
            return normalize(cross(vector, vec3(0,0,1)));
        }
    }
}


void main()
{
    const uint input_arrow_instance_index = gl_GlobalInvocationID.x;

    // Number of instances might not be a multiple of the work group size.
    if (input_arrow_instance_index >= num_input_arrow_instances)
    {
        return;
    }

    // Input arrow instance.
    const InputArrowInstance input_arrow_instance = input_arrow_instances.instances[input_arrow_instance_index];
    vec3 arrow_start = input_arrow_instance.arrow_start;
    vec3 arrow_vector = input_arrow_instance.arrow_vector;
    float arrow_body_width = input_arrow_instance.arrow_body_width;
    float arrowhead_length = input_arrow_instance.arrowhead_length;
    vec4 arrow_colour = input_arrow_instance.colour;

    // Scale the arrow vector, the arrow body width and arrowhead length according to the zoom (and whether in map view or not).
    arrow_vector *= arrow_size_scale_factor;
    arrow_body_width *= arrow_size_scale_factor;
    arrowhead_length *= arrow_size_scale_factor;

    // If using a map projection then project the arrow start and arrow vector onto the map projection.
    if (use_map_projection)
    {
        // Map project arrow start position and vector.
        vec2 arrow_start_on_map = map_project_position(arrow_start);
        vec3 arrow_vector_on_map = map_project_vector(arrow_start, arrow_vector);

        // Overwrite arrow start position and vector with map projected versions.
        arrow_start = vec3(arrow_start_on_map, 0.0);  // z component in map projection space is zero (ie, on map plane)
        arrow_vector = arrow_vector_on_map;
    }

    const float arrow_length = length(arrow_vector);
    // Avoid divide-by-zero - and if arrow length is near zero it won't be visible.
    if (arrow_length == 0)
    {
        return;
    }
    const vec3 arrow_unit_vector = (1.0 / arrow_length) * arrow_vector;

    // See if arrow instance is visible (in view frustum).
    float arrow_bounding_sphere_radius = 0.5 * arrow_length;
    vec3 arrow_bounding_sphere_centre = arrow_start + arrow_bounding_sphere_radius * arrow_unit_vector;
    if (!sphere_intersects_frustum(arrow_bounding_sphere_centre, arrow_bounding_sphere_radius))
    {
        return;
    }

    // We want to keep the projected arrowhead length constant regardless of the
    // the length of the arrow, except...
    //
    // ...if the ratio of arrowhead length to arrow length is large enough then
    // we need to start scaling the arrowhead length by the arrow length so
    // that the arrowhead disappears as the arrow disappears.
    const float max_arrowhead_length = max_ratio_arrowhead_length_to_arrow_length * arrow_length;
    if (arrowhead_length > max_arrowhead_length)
    {
        const float arrow_scale = max_arrowhead_length / arrowhead_length;

        arrowhead_length *= arrow_scale;

        // Also linearly shrink the arrow body width.
        arrow_body_width *= arrow_scale;
    }
    const float arrowhead_width = arrowhead_width_to_length_ratio * arrowhead_length;

    // Arrow body length is the total arrow length minus the arrowhead length.
    const float arrow_body_length = arrow_length - arrowhead_length;

    // Find an orthonormal basis using 'arrow_unit_vector'.
    const vec3 arrow_z_axis = arrow_unit_vector;
    const vec3 arrow_y_axis = generate_perpendicular(arrow_z_axis);
    const vec3 arrow_x_axis = cross(arrow_y_axis, arrow_z_axis);

    // Increment output arrow instance count.
    uint output_arrow_instance_index = atomicAdd(indirect_draw.command.instanceCount, 1);

    // Write output arrow instance to the output buffer.
    output_arrow_instances.instances[output_arrow_instance_index] = OutputArrowInstance(
            arrow_start, arrow_body_width,
            arrow_x_axis, arrowhead_width,
            arrow_y_axis, arrow_body_length,
            arrow_z_axis, arrowhead_length,
            arrow_colour);
}
