/**
 * Copyright (C) 2022 The University of Sydney, Australia
 *
 * This file is part of GPlates.
 *
 * GPlates is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 2, as published by
 * the Free Software Foundation.
 *
 * GPlates is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

//
// Scales arrows according to viewport zoom and culls arrows outside the view frustum.
//

layout (push_constant) uniform PushConstants
{
    vec4 frustum_planes[6];
    float inverse_viewport_zoom_factor;
    float max_ratio_arrowhead_length_to_arrow_length;
    float arrowhead_width_to_length_ratio;
    uint num_input_arrow_instances;
};

struct InputArrowInstance
{
    vec3 arrow_start;  // (x, y, z) position in world space of base of arrow
    float arrow_body_width;  // fills alignment padding
    vec3 arrow_vector;  // direction and magnitude of arrow in world space
    float arrowhead_length;  // fills alignment padding
    vec4 colour;  // arrow colour
};

struct OutputArrowInstance
{
    // Position (x, y, z) in world space of base of arrow
    vec3 world_space_start_position;
    float arrow_body_width;  // fills alignment padding

    vec3 world_space_x_axis;  // frame of reference of arrow instance
    float arrowhead_width;  // fills alignment padding

    vec3 world_space_y_axis;  // frame of reference of arrow instance
    float arrow_body_length;  // fills alignment padding

    vec3 world_space_z_axis;  // direction arrow is pointing (unit vector)
    float arrowhead_length;  // fills alignment padding

    // Arrow colour.
    vec4 colour;
};

layout (set = 0, binding = 0) readonly buffer InputArrowInstances
{
    InputArrowInstance instances[];
} input_arrow_instances;

layout (set = 0, binding = 1) writeonly buffer OutputArrowInstances
{
    OutputArrowInstance instances[];
} output_arrow_instances;

// Same layout as VkDrawIndexedIndirectCommand
struct IndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout (set = 0, binding = 2) buffer IndirectDraw
{
    IndexedIndirectCommand command;
} indirect_draw;

layout (local_size_x_id = 1) in;  // Set 'local_size_x' using the Vulkan API


/*
 * Returns true if sphere intersects frustum.
 *
 * This test is conservative, so sphere can be outside frustum and still return true.
 */
bool
sphere_intersects_frustum(
        vec3 sphere_centre,
        float sphere_radius)
{
    for (int i = 0; i < 6; i++)
    {
        if (dot(vec4(sphere_centre, 1.0), frustum_planes[i]) + sphere_radius < 0.0)
        {
            // Sphere is outside a single frustum plane.
            return false;
        }
    }

    return true;
}

/*
 * Generate an arbitray perpendicular unit vector to the specified vector.
 */
vec3
generate_perpendicular(
        vec3 vector)
{
    // Use the basis vector that's most perpendicular (lowest dot product) to the input vector.
    if (vector.x < vector.y)
    {
        if (vector.x < vector.z)
        {
            return normalize(cross(vector, vec3(1,0,0)));
        }
        else  // vector.z <= vector.x
        {
            return normalize(cross(vector, vec3(0,0,1)));
        }
    }
    else  // vector.y <= vector.x
    {
        if (vector.y < vector.z)
        {
            return normalize(cross(vector, vec3(0,1,0)));
        }
        else  // vector.z <= vector.y
        {
            return normalize(cross(vector, vec3(0,0,1)));
        }
    }
}


void main()
{
    const uint input_arrow_instance_index = gl_GlobalInvocationID.x;

    // Number of instances might not be a multiple of the work group size.
    if (input_arrow_instance_index >= num_input_arrow_instances)
    {
        return;
    }

    // Input arrow instance.
    const InputArrowInstance input_arrow_instance = input_arrow_instances.instances[input_arrow_instance_index];
    const vec3 arrow_start = input_arrow_instance.arrow_start;
    vec3 arrow_vector = input_arrow_instance.arrow_vector;
    float arrow_body_width = input_arrow_instance.arrow_body_width;
    float arrowhead_length = input_arrow_instance.arrowhead_length;
    vec4 arrow_colour = input_arrow_instance.colour;

    // Scale the arrow vector, the arrow body width and arrowhead length according to the zoom.
    arrow_vector *= inverse_viewport_zoom_factor;
    arrow_body_width *= inverse_viewport_zoom_factor;
    arrowhead_length *= inverse_viewport_zoom_factor;

    const float arrow_length = length(arrow_vector);
    // Avoid divide-by-zero - and if arrow length is near zero it won't be visible.
    if (arrow_length == 0)
    {
        return;
    }
    const vec3 arrow_unit_vector = (1.0 / arrow_length) * arrow_vector;

    // See if arrow instance is visible (in view frustum).
    float arrow_bounding_sphere_radius = 0.5 * arrow_length;
    vec3 arrow_bounding_sphere_centre = arrow_start + arrow_bounding_sphere_radius * arrow_unit_vector;
    if (!sphere_intersects_frustum(arrow_bounding_sphere_centre, arrow_bounding_sphere_radius))
    {
        return;
    }

    // We want to keep the projected arrowhead length constant regardless of the
    // the length of the arrow, except...
    //
    // ...if the ratio of arrowhead length to arrow length is large enough then
    // we need to start scaling the arrowhead length by the arrow length so
    // that the arrowhead disappears as the arrow disappears.
    const float max_arrowhead_length = max_ratio_arrowhead_length_to_arrow_length * arrow_length;
    if (arrowhead_length > max_arrowhead_length)
    {
        const float arrow_scale = max_arrowhead_length / arrowhead_length;

        arrowhead_length *= arrow_scale;

        // Also linearly shrink the arrow body width.
        arrow_body_width *= arrow_scale;
    }
    const float arrowhead_width = arrowhead_width_to_length_ratio * arrowhead_length;

    // Arrow body length is the total arrow length minus the arrowhead length.
    const float arrow_body_length = arrow_length - arrowhead_length;

    // Find an orthonormal basis using 'arrow_unit_vector'.
    const vec3 arrow_z_axis = arrow_unit_vector;
    const vec3 arrow_y_axis = generate_perpendicular(arrow_z_axis);
    const vec3 arrow_x_axis = cross(arrow_y_axis, arrow_z_axis);

    // Increment output arrow instance count.
    uint output_arrow_instance_index = atomicAdd(indirect_draw.command.instanceCount, 1);

    // Write output arrow instance to the output buffer.
    output_arrow_instances.instances[output_arrow_instance_index] = OutputArrowInstance(
            arrow_start, arrow_body_width,
            arrow_x_axis, arrowhead_width,
            arrow_y_axis, arrow_body_length,
            arrow_z_axis, arrowhead_length,
            arrow_colour);
}
