/**
 * Copyright (C) 2022 The University of Sydney, Australia
 *
 * This file is part of GPlates.
 *
 * GPlates is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 2, as published by
 * the Free Software Foundation.
 *
 * GPlates is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

//
// Scales arrows according to viewport zoom and culls arrows outside the view frustum.
//
// And performs map projection (when map view is active).
//

#include "utils/map_projection.glsl"
#include "utils/utils.glsl"

layout (push_constant) uniform PushConstants
{
    vec4 frustum_planes[6];
    bool use_map_projection;  // true/false if rendering in map/globe view
    float map_projection_central_meridian;  // only used if 'use_map_projection' is true
    float arrow_size_scale_factor;
    float max_ratio_arrowhead_length_to_arrow_length;
    float arrowhead_width_to_length_ratio;
    uint num_input_arrow_instances;
};

struct InputArrowInstance
{
    vec3 arrow_start;  // (x, y, z) position on globe of base of arrow
    float arrow_body_width;  // fills alignment padding
    vec3 arrow_vector;  // direction and magnitude of arrow in world space
    float arrowhead_length;  // fills alignment padding
    vec4 colour;  // arrow colour
};

struct OutputArrowInstance
{
    vec3 world_space_start_position;  // (x, y, z) position in world space of base of arrow
    float arrow_body_width;  // fills alignment padding

    vec3 world_space_x_axis;  // frame of reference of arrow instance
    float arrowhead_width;  // fills alignment padding

    vec3 world_space_y_axis;  // frame of reference of arrow instance
    float arrow_body_length;  // fills alignment padding

    vec3 world_space_z_axis;  // direction arrow is pointing (unit vector)
    float arrowhead_length;  // fills alignment padding

    // Arrow colour.
    vec4 colour;
};

layout (set = 0, binding = 0) readonly buffer InputArrowInstances
{
    InputArrowInstance instances[];
} input_arrow_instances;

layout (set = 0, binding = 1) writeonly buffer OutputArrowInstances
{
    OutputArrowInstance instances[];
} output_arrow_instances;

// Same layout as VkDrawIndexedIndirectCommand
struct IndexedIndirectCommand
{
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

layout (set = 0, binding = 2) buffer IndirectDraw
{
    IndexedIndirectCommand command;
} indirect_draw;

layout (set = 1, binding = 0) uniform sampler2D map_projection_samplers[3];

layout (local_size_x_id = 1) in;  // Set 'local_size_x' using the Vulkan API


void main()
{
    const uint input_arrow_instance_index = gl_GlobalInvocationID.x;

    // Number of instances might not be a multiple of the work group size.
    if (input_arrow_instance_index >= num_input_arrow_instances)
    {
        return;
    }

    // Input arrow instance.
    const InputArrowInstance input_arrow_instance = input_arrow_instances.instances[input_arrow_instance_index];
    vec3 arrow_start = input_arrow_instance.arrow_start;
    vec3 arrow_vector = input_arrow_instance.arrow_vector;
    float arrow_body_width = input_arrow_instance.arrow_body_width;
    float arrowhead_length = input_arrow_instance.arrowhead_length;
    vec4 arrow_colour = input_arrow_instance.colour;

    // Scale the arrow vector, the arrow body width and arrowhead length according to the zoom (and whether in map view or not).
    arrow_vector *= arrow_size_scale_factor;
    arrow_body_width *= arrow_size_scale_factor;
    arrowhead_length *= arrow_size_scale_factor;

    // If using a map projection then project the arrow start and arrow vector onto the map projection.
    if (use_map_projection)
    {
        // Map project arrow start position and vector.
        vec2 map_position;
        vec3 map_vector;
        if (!map_project_position_and_vector(
                map_position, map_vector,
                arrow_start, arrow_vector,
                map_projection_central_meridian,
                map_projection_samplers))
        {
            // The position is too close to either pole (North or South) to determine the direction of the vector
            // relative to the position's local East and North (since they are indeterminate).
            return;  // cull the arrow
        }

        // Overwrite arrow start position and vector with map projected versions.
        arrow_start = vec3(map_position, 0.0);  // z component in map projection space is zero (ie, on map plane)
        arrow_vector = map_vector;
    }

    const float arrow_length = length(arrow_vector);
    // Avoid divide-by-zero - and if arrow length is near zero it won't be visible.
    if (arrow_length == 0)
    {
        return;
    }
    const vec3 arrow_unit_vector = (1.0 / arrow_length) * arrow_vector;

    // See if arrow instance is visible (in view frustum).
    float arrow_bounding_sphere_radius = 0.5 * arrow_length;
    vec3 arrow_bounding_sphere_centre = arrow_start + arrow_bounding_sphere_radius * arrow_unit_vector;
    if (!sphere_intersects_frustum(arrow_bounding_sphere_centre, arrow_bounding_sphere_radius, frustum_planes))
    {
        return;
    }

    // We want to keep the projected arrowhead length constant regardless of the
    // the length of the arrow, except...
    //
    // ...if the ratio of arrowhead length to arrow length is large enough then
    // we need to start scaling the arrowhead length by the arrow length so
    // that the arrowhead disappears as the arrow disappears.
    const float max_arrowhead_length = max_ratio_arrowhead_length_to_arrow_length * arrow_length;
    if (arrowhead_length > max_arrowhead_length)
    {
        const float arrow_scale = max_arrowhead_length / arrowhead_length;

        arrowhead_length *= arrow_scale;

        // Also linearly shrink the arrow body width.
        arrow_body_width *= arrow_scale;
    }
    const float arrowhead_width = arrowhead_width_to_length_ratio * arrowhead_length;

    // Arrow body length is the total arrow length minus the arrowhead length.
    const float arrow_body_length = arrow_length - arrowhead_length;

    // Find an orthonormal basis using 'arrow_unit_vector'.
    const vec3 arrow_z_axis = arrow_unit_vector;
    const vec3 arrow_y_axis = generate_perpendicular(arrow_z_axis);
    const vec3 arrow_x_axis = cross(arrow_y_axis, arrow_z_axis);

    // Increment output arrow instance count.
    uint output_arrow_instance_index = atomicAdd(indirect_draw.command.instanceCount, 1);

    // Write output arrow instance to the output buffer.
    output_arrow_instances.instances[output_arrow_instance_index] = OutputArrowInstance(
            arrow_start, arrow_body_width,
            arrow_x_axis, arrowhead_width,
            arrow_y_axis, arrow_body_length,
            arrow_z_axis, arrowhead_length,
            arrow_colour);
}
