# Find our required libraries.
set(required_libs "Qt4" "OpenGL" "ICU" "GDAL" "Boost" "GZIP")
foreach(lib ${required_libs})
	find_package(${lib} REQUIRED)
endforeach(lib)

# Tell Qt that we use QtXML.
# NOTE: subdirectory 'CMakeList.txt' files will also see our QT_USE_* variables.
SET(QT_USE_QTXML 1)
SET(QT_USE_QTOPENGL 1)
SET(QT_USE_QTSVG 1)
include(${QT_USE_FILE})

# Tell ICU which libraries we use.
# Options are ICU_DONT_USE_ICU_CORE, ICU_USE_I18N, ICU_USE_IO, ICU_USE_DATA, ICU_USE_LE, ICU_USE_LX, ICU_USE_TU.
SET(ICU_USE_I18N 1)
SET(ICU_USE_IO 1)
include (${ICU_USE_FILE})

# Some useful utilities.
include (${CMAKE_MODULE_PATH}/Util.cmake)

#
# Generate 'global/config.h' file from 'global/config.h.in' and add HAVE_CONFIG_H compiler definition so GPlates will look for it.
#
include (${CMAKE_MODULE_PATH}/Config_h.cmake)

# Source files.
set(GPlates_SRCS
	gplates_main.cc)

set(GPlates_no_gui_SRCS
	gplates_demo_no_gui_main.cc)

# N.B.  The order in which some of these subdirectories are
# specified is significant.  For example, model must come before
# feature-visitors.  (This stops weird "undefined reference to 
# vtable for blah" error messages occurring.)
set(gui_LIBS
	qt-resources qt-widgets gui canvas-tools)
set(app_LIBS
	file-io model feature-visitors property-values)
set(util_LIBS
	maths utils global)
set(GPlates_LIBS
	${gui_LIBS} ${app_LIBS} ${util_LIBS})

# Add any include directories of generated header files here (eg, *Ui.h headers).
set(generated_headers_INCLUDE_DIRS
	${GPlates_BINARY_DIR}/src/qt-widgets)	# Autogenerated source headers are written here (eg, *Ui.h files).

# The 'include_directories' command doesn't propagate to subdirectories but any variable we set does.
# We'll use this variable in subdirectories to add these includes directories (avoids duplicating changes to subdirectories).
# External include directories:
# NOTE: Qt and ICU includes are taken care of by including QT_USE_FILE and ICU_USE_FILE.
set(external_INCLUDE_DIRS
	${OPENGL_INCLUDE_DIR} 
	${GDAL_INCLUDE_DIR}
	${GPlates_SOURCE_DIR}/src/system-fixes	# A fixed boost library file lives here.
	${Boost_INCLUDE_DIR})
# Internal include directories:
set(internal_INCLUDE_DIRS
	${GPlates_SOURCE_DIR}/src				# A lot of "#include" statements reference from this directory.
    ${generated_headers_INCLUDE_DIRS})
# NOTE: if you're doing an in-place build then SOURCE and BINARY directories are the same and
# generated source files will be mixed in with your versioned source code.

# Recurse into subdirectories - CMake continues processing this file when it returns.
# NOTE: any variables set after 'add_subdirectory' will not be visible in the subdirectory 'CMakeList.txt' files.
foreach(dir ${GPlates_LIBS})
	add_subdirectory(${dir})
endforeach(dir)

#
# Set top-level target dependencies.
# A top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or ADD_CUSTOM_TARGET.
#
# The 'qt-widgets' target generates header files so it should get built before anything that depends on it.
#
# NOTE: there's a bug in CMake 2.4.6 in 'add_dependencies'. 
#   It seems that subdirs are built in order in they  are listed provided you don't run a parallel build (eg, 'make -j').
if ("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}" STRGREATER "2.4.6")
    add_dependencies(canvas-tools qt-widgets)
    add_dependencies(gui qt-widgets)
    #add_dependencies(qt-widgets qt-resources)
endif ("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}" STRGREATER "2.4.6")

# Does the following:
# - finds '.ui' files and adds commands to create 'Ui.h' files.
# - adds dependencies on generated header files.
# - scans '.h' files for Q_OBJECT and adds commands to run Qt's moc.exe to generate 'moc_*.cc' files.
# - finds '.qrc' files and adds commands to generate '.cc' files from them.
# - adds header files to Visual Studio projects.
# - groups files in Visual Studio IDE according to type.
GPLATES_GENERATE_TARGET_SOURCES(gplates target_GPlates_SRCS ${GPlates_SRCS})
GPLATES_GENERATE_TARGET_SOURCES(gplates-no-gui target_GPlates_no_gui_SRCS ${GPlates_no_gui_SRCS})

add_executable(gplates ${target_GPlates_SRCS})
add_executable(gplates-no-gui ${target_GPlates_no_gui_SRCS})

set(all_LIBS
	${GPlates_LIBS}
	${GDAL_LIBRARY}
	${ICU_LIBRARIES}
	${QT_LIBRARIES}
	${OPENGL_LIBRARIES}
	)

# Avoid all GPlates library link dependencies on the linker command-line by
# specifying GPlates libraries twice. This gets around some dependencies
# like 'gui' depends on 'canvas-tools' depends on 'gui' depends on 'maths'.
target_link_libraries(gplates ${all_LIBS} ${GPlates_LIBS})
target_link_libraries(gplates-no-gui ${all_LIBS} ${GPlates_LIBS})

# Current binary directory must be included first for g++ pre-compiled headers.
# There's a '_pch.h' file in current source and current binary directory however the '_pch.h.gch' pre-compiled header
# is only in current binary directory and it will only be used by the compiler if it's in the same directory as the found '_pch.h' file.
# So we need to ensure that we find the '_pch.h' file from the current binary directory first.
include_directories(${CMAKE_CURRENT_BINARY_DIR})

# External library include directories are treated as system include directories.
include_directories(${SYSTEM_INCLUDE_FLAG} ${external_INCLUDE_DIRS})

# Generated source header include directories.
include_directories(${internal_INCLUDE_DIRS})

# Perform commands that modify target properties.
# We do this last because pre-compiled headers are done here and they
# require access to directory and target properties (eg, include directories).
GPLATES_POST_ADD_TARGET(gplates target_GPlates_SRCS)
GPLATES_POST_ADD_TARGET(gplates-no-gui target_GPlates_no_gui_SRCS)

install(TARGETS gplates RUNTIME DESTINATION bin CONFIGURATIONS release)
