# Find our required libraries.
set(required_libs "Qt4" "OpenGL" "ICU" "GDAL" "Boost" "GZIP" "PROJ4")
foreach(lib ${required_libs})
	find_package(${lib} REQUIRED)
endforeach(lib)

# Tell Qt that we use QtXML.
# NOTE: subdirectory 'CMakeList.txt' files will also see our QT_USE_* variables.
SET(QT_USE_QTXML 1)
SET(QT_USE_QTOPENGL 1)
SET(QT_USE_QTSVG 1)
include(${QT_USE_FILE})

# Tell ICU which libraries we use.
# Options are ICU_DONT_USE_ICU_CORE, ICU_USE_I18N, ICU_USE_IO, ICU_USE_DATA, ICU_USE_LE, ICU_USE_LX, ICU_USE_TU.
SET(ICU_USE_I18N 1)
SET(ICU_USE_IO 1)
include (${ICU_USE_FILE})

# Some useful utilities.
include (Util)

#
# Generate 'global/config.h' file from 'global/config.h.in' and add HAVE_CONFIG_H compiler definition so GPlates will look for it.
#
# This should be included after the above include and find_package calls and before the add_subdirectory calls because
# it uses the GDAL package and it sets the HAVE_CONFIG_H compiler flag needed by source code in the subdirectories.
#
include (Config_h)

#
# Generate 'global/Constants.cc' file from 'global/Constants.cc.in'.
#
# To change the current GPlates version string edit the "ConfigDefault.cmake" file.
#
include (GPlatesVersion)

# Source files.
set(GPlates_SRCS
	gplates_main.cc)

set(GPlates_no_gui_SRCS
	gplates_demo_no_gui_main.cc)

# N.B.  The order in which some of these subdirectories are
# specified is significant.  For example, model must come before
# feature-visitors.  (This stops weird "undefined reference to 
# vtable for blah" error messages occurring.)
set(gui_LIBS
	qt-resources qt-widgets gui canvas-tools view-operations)
set(app_LIBS
	model file-io feature-visitors property-values app-logic)
set(util_LIBS
	maths utils global)
set(GPlates_LIBS
	${gui_LIBS} ${app_LIBS} ${util_LIBS})

# Add any include directories of generated header files here (eg, *Ui.h headers).
set(generated_headers_INCLUDE_DIRS
	${GPlates_BINARY_DIR}/src/qt-widgets)	# Autogenerated source headers are written here (eg, *Ui.h files).

# The 'include_directories' command doesn't propagate to subdirectories but any variable we set does.
# We'll use this variable in subdirectories to add these includes directories (avoids duplicating changes to subdirectories).
# External include directories:
# NOTE: Qt and ICU includes are taken care of by including QT_USE_FILE and ICU_USE_FILE.
set(external_INCLUDE_DIRS
	${OPENGL_INCLUDE_DIR} 
	${GDAL_INCLUDE_DIR}
	${GPlates_SOURCE_DIR}/src/system-fixes	# A fixed boost library file lives here.
	${Boost_INCLUDE_DIR}
	${PROJ4_INCLUDE_DIR})
# Internal include directories:
set(internal_INCLUDE_DIRS
	${GPlates_SOURCE_DIR}/src				# A lot of "#include" statements reference from this directory.
    ${generated_headers_INCLUDE_DIRS})
# NOTE: if you're doing an in-place build then SOURCE and BINARY directories are the same and
# generated source files will be mixed in with your versioned source code.

# Recurse into subdirectories - CMake continues processing this file when it returns.
# NOTE: any variables set after 'add_subdirectory' will not be visible in the subdirectory 'CMakeList.txt' files.
foreach(dir ${GPlates_LIBS})
	add_subdirectory(${dir})
endforeach(dir)

#
# Set top-level target dependencies.
# A top-level target is one created by ADD_EXECUTABLE, ADD_LIBRARY, or ADD_CUSTOM_TARGET.
#
# The 'qt-widgets' target generates header files so it should get built before anything that depends on it.
#
# NOTE: there's a bug in CMake 2.4.6 in 'add_dependencies'. 
#   It seems that subdirs are built in order in they  are listed provided you don't run a parallel build (eg, 'make -j').
if ("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}" STRGREATER "2.4.6")
    add_dependencies(canvas-tools qt-widgets)
    add_dependencies(view-operations qt-widgets)
    add_dependencies(gui qt-widgets)
    #add_dependencies(qt-widgets qt-resources)
endif ("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}" STRGREATER "2.4.6")

# Does the following:
# - finds '.ui' files and adds commands to create 'Ui.h' files.
# - adds dependencies on generated header files.
# - scans '.h' files for Q_OBJECT and adds commands to run Qt's moc.exe to generate 'moc_*.cc' files.
# - finds '.qrc' files and adds commands to generate '.cc' files from them.
# - adds header files to Visual Studio projects.
# - groups files in Visual Studio IDE according to type.
GPLATES_GENERATE_TARGET_SOURCES(gplates target_GPlates_SRCS ${GPlates_SRCS})
GPLATES_GENERATE_TARGET_SOURCES(gplates-no-gui target_GPlates_no_gui_SRCS ${GPlates_no_gui_SRCS})

#
# Set the platform-dependent icon file.
#
if (APPLE)
	set(GPlates_ICON "${CMAKE_SOURCE_DIR}/cmake/distribution/gplates_desktop_icon.icns")
elseif (MSVC)
	set(GPlates_ICON "${CMAKE_SOURCE_DIR}/cmake/distribution/gplates_desktop_icon.rc")
else (APPLE)
endif (APPLE)

#
# Add executable target(s).
#
add_executable(gplates
	${target_GPlates_SRCS}
	${GPlates_ICON})

# The "EXCLUDE_FROM_ALL" flag means you have to type 'make gplates-no-gui' to build this target -
# it is not built by default.
add_executable(gplates-no-gui EXCLUDE_FROM_ALL ${target_GPlates_no_gui_SRCS})

# Referenced in "Package.cmake" so it knows which executable to package up.
set(GPLATES_MAIN_TARGET gplates)

if (APPLE)
	# Copy icon file to 'Resources' directory inside application bundle.
	set_source_files_properties(${GPlates_ICON} PROPERTIES
		MACOSX_PACKAGE_LOCATION Resources)

	#
	# Tell cmake to build the main target as an application bundle.
	#
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE TRUE)
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_INFO_STRING "${GPLATES_PACKAGE_DESCRIPTION_SUMMARY}")
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_ICON_FILE gplates_desktop_icon.icns)
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_GUI_IDENTIFIER "${GPLATES_VERSION_STRING}-${CMAKE_SYSTEM}")
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_LONG_VERSION_STRING "${GPLATES_VERSION_STRING}")
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "${GPLATES_PACKAGE_NAME}")
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_SHORT_VERSION_STRING "${GPLATES_PACKAGE_VERSION}")
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_BUNDLE_VERSION "${GPLATES_PACKAGE_VERSION}")
	set_target_properties(${GPLATES_MAIN_TARGET}
		PROPERTIES MACOSX_BUNDLE_COPYRIGHT "${GPLATES_COPYRIGHT_STRING}")
endif (APPLE)

set(all_LIBS
	${GPlates_LIBS}
	${GDAL_LIBRARY}
	${ICU_LIBRARIES}
	${QT_LIBRARIES}
	${OPENGL_LIBRARIES}
	${PROJ4_LIBRARY}
	)

# Avoid all GPlates library link dependencies on the linker command-line by
# specifying GPlates libraries twice. This gets around some dependencies
# like 'gui' depends on 'canvas-tools' depends on 'gui' depends on 'maths'.
target_link_libraries(gplates ${all_LIBS} ${GPlates_LIBS})
target_link_libraries(gplates-no-gui ${all_LIBS} ${GPlates_LIBS})

# Current binary directory must be included first for g++ pre-compiled headers.
# There's a '_pch.h' file in current source and current binary directory however the '_pch.h.gch' pre-compiled header
# is only in current binary directory and it will only be used by the compiler if it's in the same directory as the found '_pch.h' file.
# So we need to ensure that we find the '_pch.h' file from the current binary directory first.
include_directories(${CMAKE_CURRENT_BINARY_DIR})

# External library include directories are treated as system include directories.
include_directories(${SYSTEM_INCLUDE_FLAG} ${external_INCLUDE_DIRS})

# Generated source header include directories.
include_directories(${internal_INCLUDE_DIRS})

# Perform commands that modify target properties.
# We do this last because pre-compiled headers are done here and they
# require access to directory and target properties (eg, include directories).
GPLATES_POST_ADD_TARGET(gplates target_GPlates_SRCS)
GPLATES_POST_ADD_TARGET(gplates-no-gui target_GPlates_no_gui_SRCS)

if (APPLE)
    install(TARGETS gplates
    	RUNTIME DESTINATION bin
    	BUNDLE DESTINATION bin
    	CONFIGURATIONS release)
else (APPLE)
    # CMake 2.4 doesn't know about "BUNDLE DESTINATION" so don't force Windows/Linux users
    # to require CMake 2.6.
    install(TARGETS gplates
    	RUNTIME DESTINATION bin
    	CONFIGURATIONS release)
endif (APPLE)

# Include the package module which adds a 'package' target that packages up
# a standalone version of GPlates (with dependent libraries included) for distribution
# to another computer.
#
# NOTE: we don't include if CMake version is less than 2.6 because the
# "package" module uses some commands, such as 'function', that were
# introduced in CMake 2.6. This means you must have CMake 2.6 or better
# to create binary install packages for distribution.
#
if ("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" STRGREATER "2.5")
    include(Package)
endif ("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" STRGREATER "2.5")
