/* $Id$ */

/**
 * \file 
 * $Revision$
 * $Date$
 * 
 * Copyright (C) 2009 The University of Sydney, Australia
 *
 * This file is part of GPlates.
 *
 * GPlates is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 2, as published by
 * the Free Software Foundation.
 *
 * GPlates is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef GPLATES_APP_LOGIC_APPLICATIONSTATE_H
#define GPLATES_APP_LOGIC_APPLICATIONSTATE_H

#include <vector>
#include <boost/noncopyable.hpp>
#include <boost/scoped_ptr.hpp>
#include <QObject>

#include "model/FeatureCollectionHandle.h"
#include "model/ModelInterface.h"
#include "model/Reconstruction.h"
#include "model/ReconstructionTree.h"
#include "model/types.h"

////////////////////////////////////////////////////////////////////////////////////////////////
// NOTE: Please use forward declarations (and boost::scoped_ptr) instead of including headers
// where possible.
// This header gets included in a lot of other files and we want to reduce compile times.
////////////////////////////////////////////////////////////////////////////////////////////////


namespace GPlatesAppLogic
{
	class FeatureCollectionFileIO;
	class FeatureCollectionFileState;
	class LayerTaskRegistry;
	class ReconstructionActivationStrategy;


	/**
	 * Stores state that deals with the model and feature collection files.
	 */
	class ApplicationState :
			public QObject,
			private boost::noncopyable
	{
		Q_OBJECT

	public:
		/**
		 * Interface class for calling client-defined code before and after each reconstruction.
		 */
		class ReconstructHook
		{
		public:
			virtual
			~ReconstructHook()
			{  }


			/**
			 * Called before a reconstruction is created.
			 */
			virtual
			void
			begin_reconstruction(
					GPlatesModel::ModelInterface &model,
					const double &reconstruction_time,
					GPlatesModel::integer_plate_id_type reconstruction_anchored_plate_id)
			{  }


			/**
			 * Called after a reconstruction is created.
			 *
			 * The created reconstruction is passed as @a reconstruction.
			 */
			virtual
			void
			end_reconstruction(
					GPlatesModel::ModelInterface &model,
					GPlatesModel::Reconstruction &reconstruction,
					const double &reconstruction_time,
					GPlatesModel::integer_plate_id_type reconstruction_anchored_plate_id,
					const std::vector<GPlatesModel::FeatureCollectionHandle::weak_ref> &
							reconstructable_features_collection,
					const std::vector<GPlatesModel::FeatureCollectionHandle::weak_ref> &
							reconstruction_features_collection)
			{  }
		};


		ApplicationState();

		~ApplicationState();

		/**
		 * Sets the reconstruction hook to be called when a reconstruction is next done.
		 *
		 * Default for @a reconstruction_hook means do nothing.
		 *
		 * FIXME: remove this when we switch to using @a ReconstructGraph instead of !Reconstruct.
		 */
		void
		set_reconstruction_hook(
				ReconstructHook *reconstruction_hook = NULL);

		GPlatesModel::ModelInterface &
		get_model_interface()
		{
			return d_model;
		}

		const double &
		get_current_reconstruction_time() const
		{
			return d_reconstruction_time;
		}

		GPlatesModel::integer_plate_id_type
		get_current_anchored_plate_id() const
		{
			return d_anchored_plate_id;
		}

		/**
		 * Returns the reconstruction generated by the most recent reconstruction.
		 */
		GPlatesModel::Reconstruction &
		get_current_reconstruction();

		/**
		 * Returns the reconstruction as a non-null shared pointer to non-const.
		 */
		GPlatesModel::Reconstruction::non_null_ptr_type
		get_current_reconstruction_non_null_ptr();

		/**
		 * Keeps track of active feature collections loaded from files.
		 */
		GPlatesAppLogic::FeatureCollectionFileState &
		get_feature_collection_file_state();


		/**
		 * Handling reading/writing feature collection files and notification of read errors.
		 */
		GPlatesAppLogic::FeatureCollectionFileIO &
		get_feature_collection_file_io();

	public slots:
		// NOTE: all signals/slots should use namespace scope for all arguments
		//       otherwise differences between signals and slots will cause Qt
		//       to not be able to connect them at runtime.

		/**
		 * Sets the reconstruction time and if the reconstruction time has changed
		 * performs a new reconstruction and emits the @a reconstruction_time_changed and
		 * @a reconstructed signals.
		 */
		void
		set_reconstruction_time(
				const double &reconstruction_time);

		/**
		 * Sets the anchor plate id and if the anchor plate id has changed
		 * performs a new reconstruction and emits the @a anchor_plate_id_changed and
		 * @a reconstructed signals.
		 */
		void
		set_anchored_plate_id(
				unsigned long anchor_plate_id);

		/**
		 * Performs a reconstruction and emits the @a reconstructed signal.
		 */
		void
		reconstruct();

	signals:
		// NOTE: all signals/slots should use namespace scope for all arguments
		//       otherwise differences between signals and slots will cause Qt
		//       to not be able to connect them at runtime.

		//! Emitted when the reconstruction time has changed.
		void
		reconstruction_time_changed(
				GPlatesAppLogic::ApplicationState &application_state,
				const double &new_reconstruction_time);

		//! Emitted when the anchor plate id has changed.
		void
		anchor_plate_id_changed(
				GPlatesAppLogic::ApplicationState &application_state,
				const GPlatesModel::integer_plate_id_type &new_anchor_plate_id);

		//! Emitted when @a reconstruct called.
		void
		reconstructed(
				GPlatesAppLogic::ApplicationState &application_state);

	private:
		GPlatesModel::ModelInterface d_model;

		/**
		 * The current reconstruction time.
		 */
		double d_reconstruction_time;

		/**
		 * The current plate id that all reconstruction trees are currently anchored.
		 */
		GPlatesModel::integer_plate_id_type d_anchored_plate_id;

		GPlatesModel::ReconstructionTree::non_null_ptr_type d_reconstruction_tree;
		GPlatesModel::Reconstruction::non_null_ptr_type d_reconstruction;

		//
		// NOTE: Most of these are boost::scoped_ptr's to avoid having to include header files.
		//

		boost::scoped_ptr<LayerTaskRegistry> d_layer_task_registry;

		boost::scoped_ptr<ReconstructionActivationStrategy> d_reconstruction_activation_strategy;
		boost::scoped_ptr<FeatureCollectionFileState> d_feature_collection_file_state;
		boost::scoped_ptr<FeatureCollectionFileIO> d_feature_collection_file_io;

		ReconstructHook *d_reconstruction_hook;


		/**
		 * Make signal/slot connections that coordinate the application logic structure
		 * of the application.
		 *
		 * This is a central place to coordinate these connections - a bit like a mediator.
		 */
		void
		mediate_signal_slot_connections();
	};
}

#endif // GPLATES_APP_LOGIC_APPLICATIONSTATE_H
