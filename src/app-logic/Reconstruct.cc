/* $Id$ */

/**
 * \file Reconstructs feature geometry(s) from present day to the past.
 * $Revision$
 * $Date$
 * 
 * Copyright (C) 2009 The University of Sydney, Australia
 *
 * This file is part of GPlates.
 *
 * GPlates is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 2, as published by
 * the Free Software Foundation.
 *
 * GPlates is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "Reconstruct.h"

#include "model/ReconstructionGraph.h"
#include "model/ReconstructionTreePopulator.h"
#include "model/ReconstructedFeatureGeometryPopulator.h"

#include "feature-visitors/TopologyResolver.h"


namespace 
{
	template< typename FeatureCollectionIterator >
	void
	visit_feature_collections(
			FeatureCollectionIterator collections_begin, 
			FeatureCollectionIterator collections_end,
			GPlatesModel::FeatureVisitor &visitor)
	{
		using namespace GPlatesModel;

		// We visit each of the features in each of the feature collections in
		// the given range.
		FeatureCollectionIterator collections_iter = collections_begin;
		for ( ; collections_iter != collections_end; ++collections_iter) {

			FeatureCollectionHandle::weak_ref feature_collection = *collections_iter;

			// Before we dereference the weak_ref using 'operator->',
			// let's be sure that it's valid to dereference.
			if (feature_collection.is_valid()) {
				FeatureCollectionHandle::features_iterator iter =
						feature_collection->features_begin();
				FeatureCollectionHandle::features_iterator end =
						feature_collection->features_end();
				for ( ; iter != end; ++iter) {
					(*iter)->accept_visitor(visitor);
				}
			}
		}
	}
}


const GPlatesModel::ReconstructionTree::non_null_ptr_type
GPlatesAppLogic::create_reconstruction_tree(
		const std::vector<GPlatesModel::FeatureCollectionHandle::weak_ref> &
				reconstruction_features_collection,
		const double &time,
		GPlatesModel::integer_plate_id_type root)
{
	GPlatesModel::ReconstructionGraph graph(time);
	GPlatesModel::ReconstructionTreePopulator rtp(time, graph);

	visit_feature_collections(
			reconstruction_features_collection.begin(),
			reconstruction_features_collection.end(),
			rtp);

	// Build the reconstruction tree, using 'root' as the root of the tree.
	GPlatesModel::ReconstructionTree::non_null_ptr_type tree = graph.build_tree(root);
	return tree;
}


std::pair<
		const GPlatesModel::Reconstruction::non_null_ptr_type,
		boost::shared_ptr<GPlatesFeatureVisitors::TopologyResolver> >
GPlatesAppLogic::create_reconstruction(
		const std::vector<GPlatesModel::FeatureCollectionHandle::weak_ref> &
				reconstructable_features_collection,
		const std::vector<GPlatesModel::FeatureCollectionHandle::weak_ref> &
				reconstruction_features_collection,
		const double &time,
		GPlatesModel::integer_plate_id_type root)
{
	GPlatesModel::ReconstructionTree::non_null_ptr_type tree =
			create_reconstruction_tree(reconstruction_features_collection, time, root);
	GPlatesModel::Reconstruction::non_null_ptr_type reconstruction =
			GPlatesModel::Reconstruction::create(tree, reconstruction_features_collection);

	GPlatesModel::ReconstructedFeatureGeometryPopulator rfgp(time, root, *reconstruction,
			reconstruction->reconstruction_tree(),
			reconstruction->geometries());

	visit_feature_collections(
		reconstructable_features_collection.begin(),
		reconstructable_features_collection.end(),
		rfgp);

	// Visit the feature collections and build topologies.
	// TopologyResolver is currently referenced by ComputationalMeshSolver
	// so we return it to the caller.
	// FIXME: Move TopologyResolver.cc into 'app-logic/' and use GPlatesAppLogic namespace.
	// FIXME: Divide TopologyResolver into two parts:
	//        1) part that generates topology RFG (that part stays here).
	//        2) part that tests a point against topologies (that part will have to
	//           use the RFG generated by part 1 and should be moved to a separate class).
	//        When/if that's done then the new TopologyResolver (part 1) can be
	//        a local variable here and won't need to be returned to the caller.
	boost::shared_ptr<GPlatesFeatureVisitors::TopologyResolver> topology_resolver(
			new GPlatesFeatureVisitors::TopologyResolver(
					time,
					root,
					*reconstruction,
					reconstruction->reconstruction_tree(),
					reconstruction->geometries(),
					true)); // keep features without recon plate id

	visit_feature_collections(
		reconstructable_features_collection.begin(),
		reconstructable_features_collection.end(),
		*topology_resolver);

	// topology_resolver->report();

	return std::make_pair(reconstruction, topology_resolver);
}
